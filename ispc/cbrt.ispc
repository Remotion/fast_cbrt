/*
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/*
Copyright (c) 2021 - present, Remotion (Igor Schulz)
All Rights Reserved
*/


// varying or uniform
//#define param__ uniform 
#define param__ varying 

static inline unsigned int32 uintbits(float a) {
    return __intbits_varying_float(a);
}

static inline uniform unsigned int32 uintbits(uniform float a) {
    return __intbits_uniform_float(a);
}

static inline unsigned int64 uintbits(double d) {
    return __intbits_varying_double(d);
}

static inline uniform unsigned int64 uintbits(uniform double d) {
    return __intbits_uniform_double(d);
}



/// n % 3
static inline param__ uint32 modu3(param__ uint32 n) {
	return (0x55555555u * n + (n >> 1) - (n >> 3)) >> 30;
}

/// n / 3
static inline param__ uint32 divu3(param__ uint32 n, param__ uint32 mod3_res) {
	return (n - mod3_res) * 0xAAAAAAABu;
}

/// cube-root based on sleef
/// https://github.com/shibatch/sleef/wiki/Divisionless-iterative-approximation-method-of-cube-root

static inline param__ float pow2if(param__ int32 q) { return floatbits(((int32)(q + 0x7f)) << 23); }

static inline param__ float ldexp2kf(param__ float d, param__  int32 e) { return d * pow2if(e >> 1) * pow2if(e - (e >> 1)); }

static inline param__ int32 ilogbkf(param__ float d) {
	param__ bool m = d < floatbits(0x1f800000); // 5.421010862427522E-20f
	d = select(m,floatbits(0x5f800000) * d, d); // 1.8446744073709552E19f
	param__ int32 q = (intbits(d) >> 23) & 0xff;
	q = select(m,q - (64 + 0x7f), q - 0x7f);
	return q;
}

static inline param__ float mulsignf(param__ float x,param__ float y) { return floatbits(intbits(x) ^ (intbits(y) & 0x80000000)); }

// fused multiply add
static inline param__ float madf(param__ float x,param__ float y,param__ float z) { return x * y + z; }

// cube-root for float
// ulp: 3 | average_ulp: ~0.4 | ulp_histo: | 0: 61.3% | 1: 38.1% | 2: 0.583% | 3: 4.21e-05% |
param__ float cbrtf(param__ float d) 
{
	param__ float x, y, q = 1.0f;
	param__ int32 e, r;

	e = ilogbkf(abs(d)) + 1;
	d = ldexp2kf(d, -e);
	e = e + 6144;
    r = modu3(e); // e % 3 
	q = select(r == 1, 1.2599210498948731647672106f, q); // q = (r == 1) ? 1.2599210498948731647672106f : q;
	q = select(r == 2, 1.5874010519681994747517056f, q); // q = (r == 2) ? 1.5874010519681994747517056f : q;
    q = ldexp2kf(q, divu3(e,r) - 2048); // e / 3 

	q = mulsignf(q, d);
	d = abs(d);

	x = -0.601564466953277587890625f;
	x = madf(x, d,  2.8208892345428466796875f);
	x = madf(x, d, -5.532182216644287109375f);
	x = madf(x, d,  5.898262500762939453125f);
	x = madf(x, d, -3.8095417022705078125f);
	x = madf(x, d,  2.2241256237030029296875f);

	y = d * x * x;
	y = (y - (2.0f / 3.0f) * y * (y * x - 1.0f)) * q;

	return y;
}



static inline param__ double pow2i(param__ int32 q) {	return doublebits(((int64)(q + 0x3ff)) << 52); }

static inline param__ double ldexp2k(param__ double d,param__ int32 e) { return d * pow2i(e >> 1) * pow2i(e - (e >> 1)); }

static inline param__ int32 ilogbk(param__ double d) { 
	param__ bool m = d < doublebits(0x2d30000000000000); // 4.9090934652977266E-91
	d = select(m,doublebits(0x52b0000000000000) * d, d); // 2.037035976334486E90
	param__ int32 q = (uintbits(d) >> 52) & 0x7ff;
	q = select(m, q - (300 + 0x03ff), q - 0x03ff);
	return q;
}

static inline param__ double mulsign(param__ double x, param__ double y) { return doublebits(uintbits(x) ^ (uintbits(y) & 0x8000000000000000)); }

// fused multiply add
static inline param__ double mad(param__ double x, param__ double y, param__ double z) { return x * y + z; } 

// cube-root for double
// ulp: 3 | average_ulp: ~0.4 | ulp_histo: | 0: 57.8% | 1: 41% | 2: 1.23% | 3: 2e-05% |
param__ double cbrt(param__ double d)
{
	param__ double x, y, q = 1.0;
	param__ int32 e, r;

	e = ilogbk(abs(d)) + 1;
	d = ldexp2k(d, -e);
	e = e + 6144;
	r = modu3(e); // r = (e + 6144) % 3;
	q = select(r == 1, doublebits(0x3ff428a2f98d728b), q); // q = (r == 1) ? 1.2599210498948731647672106 : q;
	q = select(r == 2, doublebits(0x3ff965fea53d6e3d), q); // q = (r == 2) ? 1.5874010519681994747517056 : q;
	q = ldexp2k(q, divu3(e,r) - 2048); // q = ldexp2(q, (e + 6144) / 3 - 2048);

	q = mulsign(q, d);
	d = abs(d);

	x = doublebits(0xbfe47ce4f76bed42); // -0.640245898480692909870982
	x = mad(x, d, doublebits(0x4007b141aaa12a9c)); //  2.96155103020039511818595
	x = mad(x, d, doublebits(0xc016ef22a5e505b3)); // -5.73353060922947843636166
	x = mad(x, d, doublebits(0x401828dc834c5911)); //  6.03990368989458747961407
	x = mad(x, d, doublebits(0xc00ede0af7836a8b)); // -3.85841935510444988821632
	x = mad(x, d, doublebits(0x4001d887ace5ac54)); //  2.2307275302496609725722

	const param__ double one_third = doublebits(0x3fd5555555555555); // (1.0 / 3.0)
	const param__ double two_third = doublebits(0x3fe5555555555555); // (2.0 / 3.0)
	const param__ double one = doublebits(0x3ff0000000000000); // 1.0

	y = x * x;
	y = y * y;
	x -= (d * y - x) * (one_third);

	y = d * x * x;

	y = (y - (two_third) * y * (y * x - one)) * q;
	return y;
}




export uniform float test_cbrtf(uniform float x) { 
    // return cbrtf(x);
	return extract(cbrtf(x),1);
}

export uniform double test_cbrt(uniform double x) {
    // return cbrt(x);
	return extract(cbrt(x),1);
}

